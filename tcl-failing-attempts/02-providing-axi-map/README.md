**This does not work**, well, to be honest it looks like something acceptable. It doesn't satisfy me completely (see end of the page) so I still mark this as a  **Don't do that**.

The minimalistic example had really no chance of working. Besides, who generates the C drivers?
Before moving on however, I was struck by curiosity of providing an AXI map explicitly. I will be also moving the files to the correct location *before* attempting a creation. This second part is a bit of an anomaly as the *wrapper* and *big mux* files are typically generated by `generate_peripheral`, so I often resolved to overwrite them.

I have generated the AXI map commands by replicating object state from the [GUI-generated device](../../pseudo-reference/bus-interfaces.md).

While I would rather avoid going this route (a lot of TCL which is bundled in `generate_peripheral`), I'm interested in seeing where [this](./axi_map_n_cp_files.tcl) goes. What are the difference, why did I introduce them and what do I expect?

| What                        | Where               | Why                                                                                         |
|-----------------------------|---------------------|---------------------------------------------------------------------------------------------|
| Unique output directory     | head,<br>LN1-4      | In the minimalistic example the device was stored in a path too different from canon.<br>Give better hint to users about correspondances and goal.   |
| Manually copied files       | beginning,<br>LN18+ | The minimalistic example didn't copy files for us producing invalid file references. |
| Set up AXI ports and maps   | Most of the file<br>LN56-188 | The minimalistic example didn't infer ports (probably because there is a specific `merge_project_changes ports` for that, but I wanted to show the required set up here) |
| Change the file group props | end,<br>LN197-211   | GUI-generated components use "Advanced" file groups; set top module missing from the minimalistic example |

# Outcome

Execute the script, then `write_peripheral $periph` and `start_gui`. In Vivado TCL console, `ipx::open_ipxact_file ./_tmp_packing_add_some_bitz_0.7/component.xml`. What do I observe?

**Opening the packager generates no warnings nor errors**, albeit the warning about SystemVerilog top file continues to be issued (generated previously by `ipx::merge_project_changes`).

1. Identification OK
2. Compatibility OK
3. File groups OK
4. Customization parameters are *not quite* right (but they're not really part of this test)
    1. Missing `C_S00_AXI_BASEADDR` and the corresponding `_HIGHADDR`; are those generated by driver creation? Are they part of the generation by memory maps?
    2. `C_S00_AXI_DATA_WIDTH` description is missing (not a big deal, I admit)
    3. `C_S00_AXI_ADDR_WIDTH` description is missing (again, I don't care much but still)
    4. Validation missing, OFC merging HDL params can't infer those
    5. Everything is under "hidden parameters"
5. Ports and interfaces OK
6. Addressing and memory
    1. Address block differs by naming.
    2. Address block *Range dependency* property is unset in the GUI-generated component; it is procedurally generated in this case as `pow(2,(C_S00_AXI_ADDR_WIDTH - 1) + 1)`
        1. Very interesting and cool but what for?
        2. Possibly useful for microblaze and other address-memory-range scarce devices?
7. Customization GUI: nothing here.

Let's examine the generated GUI by `ipx::create_xgui_files [ipx::current_core]`.
Again, no errors are generated and the produced GUI looks kinda right.

# Conclusion

Suprisingly, I rate this a single ðŸ’© because the thing looks like working. It's a lot of work.

Most importantly there are no `.c` drivers generated. I'm inclined to believe those could also be generated at block design time at *generate output products* but my goal is to produce an AXI component looking very much like canonical GUI-based generation so I'll need to move on.
